// Generated by CoffeeScript 1.4.0

/*
Visualization
*/


(function() {
  var CHART_HEIGHT, CHART_WIDTH, LABEL_PROP_NAME, PADDING, PT_RADIUS, X_DIM, X_DIM_INDEX, X_TICKS, Y_DIM, Y_DIM_INDEX, Y_TICKS, addToSelectedDimensions, getMinAndMaxRangeForFeatures, removeFromSelectedDimensions, selectedDimensions, svg, updateLegend, updatePlotPoints;

  window.Viz = {};

  X_DIM = {};

  Y_DIM = {};

  X_DIM_INDEX = false;

  Y_DIM_INDEX = false;

  LABEL_PROP_NAME = "label";

  CHART_WIDTH = 475;

  CHART_HEIGHT = 450;

  PT_RADIUS = 4;

  X_TICKS = 8;

  Y_TICKS = 8;

  PADDING = CHART_WIDTH / 6;

  selectedDimensions = [];

  window.Viz.data = {};

  svg = null;

  getMinAndMaxRangeForFeatures = function(instances) {
    /*
        Calculates the min & max values for each feature across all instances
    
        @param - the instances to be visualized
        @return - Object of the form:
           {
             "domainMin": 0
             "domainMax": instances.length
               "features" : [
                 "name": < feature name >,
                 "minVal" : < min value for feature >,
                 "maxVal" : < max value for feature >
               ]
           }
    */

    var floatVal, inst, max, min, prop, propNames, returnObj, value, _i, _j, _len, _len1, _ref;
    returnObj = {
      "domainMin": 0,
      "domainMax": instances.length,
      features: []
    };
    propNames = [];
    _ref = instances[0];
    for (prop in _ref) {
      value = _ref[prop];
      if (prop !== LABEL_PROP_NAME && instances[0].hasOwnProperty(prop)) {
        propNames.push(prop);
      }
    }
    for (_i = 0, _len = propNames.length; _i < _len; _i++) {
      prop = propNames[_i];
      min = Number.MAX_VALUE;
      max = Number.MIN_VALUE;
      for (_j = 0, _len1 = instances.length; _j < _len1; _j++) {
        inst = instances[_j];
        floatVal = parseFloat(inst[prop]);
        min = floatVal < min ? floatVal : min;
        max = floatVal > max ? floatVal : max;
      }
      returnObj.features.push({
        "name": prop,
        "minVal": min,
        "maxVal": max
      });
    }
    return returnObj;
  };

  Viz.scatterPlot = function() {
    /*
        Draws a new scatter plot based on supplied list of data
        @param data - Object of the form:
          {
            "instances" : [
              {
                "feature_0" : "val_0",
                ...
                "feature_N" : "val_N",
                "label" : "label_val"
              }
            ],
            "labels" : [
              "label_0",
              ...
              "label_N"
            ]
          }
        @return - Nothing.
    */

    var categoryScale, domainRangeObj, legendXScale, xAxis, xScale, yAxis, yScale;
    domainRangeObj = getMinAndMaxRangeForFeatures(window.Viz.data.instances);
    X_DIM = X_DIM_INDEX ? domainRangeObj.features[parseInt(X_DIM_INDEX)] : {
      "minVal": 0,
      "maxVal": window.Viz.data.instances.length - 1,
      "name": "dummy"
    };
    console.log("X_DIM_INDEX:");
    console.log(X_DIM_INDEX);
    console.log("X_DIM:");
    console.log(X_DIM);
    Y_DIM = Y_DIM_INDEX ? domainRangeObj.features[parseInt(Y_DIM_INDEX)] : {
      "minVal": 0,
      "maxVal": window.Viz.data.instances.length - 1,
      "name": "dummy"
    };
    console.log("Y_DIM_INDEX:");
    console.log(Y_DIM_INDEX);
    console.log("Y_DIM:");
    console.log(Y_DIM);
    xScale = d3.scale.linear().domain([X_DIM.minVal, X_DIM.maxVal]).range([PADDING, CHART_WIDTH - PADDING]);
    yScale = d3.scale.linear().domain([Y_DIM.minVal, Y_DIM.maxVal]).range([CHART_HEIGHT - PADDING, PADDING]);
    categoryScale = d3.scale.ordinal().domain(window.Viz.data.labels).range(d3.scale.category10().range());
    xAxis = d3.svg.axis().scale(xScale).orient("bottom").ticks(X_TICKS);
    yAxis = d3.svg.axis().scale(yScale).orient("left").ticks(Y_TICKS);
    legendXScale = d3.scale.linear().domain([0, window.Viz.data.labels.length - 1]).range([PADDING, (CHART_WIDTH / 1.3) - PADDING]);
    svg.selectAll("rect.legend-rect").data(Viz.data.labels).enter().append("rect").attr("class", "legend-rect").attr("x", function(d, i) {
      return legendXScale(i);
    }).attr("y", function(d, i) {
      return PADDING / 3;
    }).attr("width", 10).attr("height", 10).style("fill", function(d, i) {
      return categoryScale(window.Viz.data.labels[i]);
    });
    svg.selectAll("text.legend").data(Viz.data.labels).enter().append("text").attr("class", "legend").attr("x", function(d, i) {
      return legendXScale(i) + 15;
    }).attr("y", function(d, i) {
      return (PADDING / 3) + 10;
    }).text(function(d, i) {
      return Viz.data.labels[i];
    }).style("font-family", "Helvetica Neue, Helvetica, Arial, sans-serif").style("font-size", "11px");
    svg.selectAll("g.axis").remove();
    svg.append("g").attr("class", "x axis").attr("id", "x-axis").attr("transform", "translate(0, " + (CHART_HEIGHT - PADDING) + " )").transition().duration(250).call(xAxis);
    svg.append("g").attr("class", "y axis").attr("id", "y-axis").attr("transform", "translate( " + PADDING + ", 0)").transition().duration(250).call(yAxis);
    svg.select("text.x-label").remove();
    svg.append("text").attr("class", "x-label").attr("text-anchor", "end").attr("x", CHART_WIDTH - PADDING).attr("y", CHART_HEIGHT - (PADDING - 35)).style("fill", "#000000").text(function() {
      if (X_DIM_INDEX) {
        return X_DIM.name;
      } else {
        return "Select X";
      }
    });
    svg.select("text.y-label").remove();
    svg.append("text").attr("class", "y-label").attr("text-anchor", "end").attr("y", PADDING - 60).attr("dx", PADDING * -1.1).attr("dy", ".75em").attr("transform", "rotate(-90)").style("fill", "#000000").text(function() {
      if (Y_DIM_INDEX) {
        return Y_DIM.name;
      } else {
        return "Select Y";
      }
    });
    updatePlotPoints(svg, window.Viz.data, xScale, yScale, xAxis, yAxis, categoryScale);
    return updateLegend(svg, window.Viz.data, legendXScale, categoryScale);
  };

  updatePlotPoints = function(svg, data, xScale, yScale, xAxis, yAxis, categoryScale) {
    /*
        Main method which controls the points on the plot as selections
        are made on the data table
    */

    var plotPoints, t0;
    plotPoints = svg.selectAll("circle").data(data.instances);
    t0 = svg.transition().duration(1000).delay(250);
    t0.selectAll('circle').attr("cx", function(d, i) {
      var scaleInput;
      console.log("X_DIM.name: " + d[X_DIM.name]);
      scaleInput = X_DIM.name !== "dummy" ? d[X_DIM.name] : i;
      return xScale(scaleInput);
    }).attr("cy", function(d, i) {
      var scaleInput;
      scaleInput = Y_DIM.name !== "dummy" ? d[Y_DIM.name] : 0;
      return yScale(scaleInput);
    }).attr("r", PT_RADIUS).style("fill", function(d) {
      return categoryScale(d.label);
    });
    plotPoints.enter().append("circle").attr("cx", function(d, i) {
      var scaleInput;
      scaleInput = X_DIM.name !== "dummy" ? d[X_DIM.name] : i;
      return xScale(scaleInput);
    }).attr("cy", function(d, i) {
      return CHART_HEIGHT * Math.random();
    }).transition().duration(2000).delay(200).attr("cy", function(d, i) {
      var scaleInput;
      scaleInput = Y_DIM.name !== "dummy" ? d[Y_DIM.name] : 0;
      return yScale(scaleInput);
    }).attr("r", PT_RADIUS).style("fill", function(d) {
      return categoryScale(d.label);
    });
    plotPoints.exit().remove();
    svg.select('#x-axis').transition().duration(1000).delay(200).call(xAxis);
    return svg.select('#y-axis').transition().duration(1000).delay(200).call(yAxis);
  };

  updateLegend = function(svg, data, legendXScale, categoryScale) {
    /*
        Updates the legend.
    */

    var legendRectangles, legendText;
    legendText = svg.selectAll("text.legend").data(data.labels);
    legendText.transition().duration(500).delay(0).attr("x", function(d, i) {
      return legendXScale(i) + 15;
    }).attr("y", function(d, i) {
      return (PADDING / 3) + 10;
    }).text(function(d, i) {
      return data.labels[i];
    });
    legendText.exit().remove();
    legendRectangles = svg.selectAll("rect.legend-rect").data(data.labels);
    legendRectangles.transition().duration(500).delay(0).attr("x", function(d, i) {
      return legendXScale(i);
    }).attr("y", function(d, i) {
      return PADDING / 3;
    });
    return legendRectangles.exit().remove();
  };

  addToSelectedDimensions = function(dimension) {
    /*
        A user has selected a dimension checkbox on the data table
        This updates the global able which keeps track of what's
        been checked and passes that to the viz
    */

    var index;
    selectedDimensions.push(dimension);
    if (selectedDimensions.length > 2) {
      index = selectedDimensions.splice(0, 1);
      $("li.feature-select.multicheck[value=" + index[0] + "]").removeClass('checked');
      $("li.feature-select.multicheck[value=" + index[0] + "]").find("span").removeClass("icon-ok");
    }
    X_DIM_INDEX = selectedDimensions[0];
    Y_DIM_INDEX = selectedDimensions[1];
    return Viz.scatterPlot();
  };

  removeFromSelectedDimensions = function(dimension) {
    /*
        A user has de-selected a dimension checkbox on the data table
        This updates the global variable (selectedDimesnsion) which keeps track of what's
        been checked and passes that to the viz
    */

    var removeIndex;
    removeIndex = selectedDimensions.indexOf(dimension);
    selectedDimensions.splice(removeIndex, 1);
    if (selectedDimensions.length < 2) {
      X_DIM_INDEX = null;
      Y_DIM_INDEX = null;
    } else {
      X_DIM_INDEX = selectedDimensions[0];
      Y_DIM_INDEX = selectedDimensions[1];
    }
    return Viz.scatterPlot();
  };

  Viz.reloadData = function() {
    return $.ajax({
      url: Dataset.updateVisualizationUrl,
      type: "POST",
      data: {
        "pk": Dataset.id
      },
      dataType: 'json',
      success: function(data) {
        Viz.data = data;
        Viz.scatterPlot();
        return true;
      },
      crossDomain: false,
      cache: false
    });
  };

  jQuery(function() {
    $.ajax({
      url: Dataset.updateVisualizationUrl,
      type: "GET",
      data: {
        "pk": Dataset.id
      },
      dataType: 'json',
      success: function(data) {
        window.Viz.data = data;
        svg = d3.select("div#chart").append("svg").attr("width", CHART_WIDTH).attr("height", CHART_HEIGHT);
        return Viz.scatterPlot();
      },
      crossDomain: false,
      cache: false
    });
    return $('li.feature-select.multicheck').on('click', function() {
      var self, val;
      self = this;
      val = $(self).val();
      if ($(self).hasClass('checked')) {
        return addToSelectedDimensions(val);
      } else {
        return removeFromSelectedDimensions(val);
      }
    });
  });

}).call(this);
